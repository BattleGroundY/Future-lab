WEBVTT

1
00 : 00 : 00.510 -> 00 : 00 : 01.280
이전 비디오에서

2
00 : 00 : 01.280 -> 00 : 00 : 06.130
우리는 계산 그래프를 사용하여 함수 J를 
계산하는 예를 보았습니다.

3
00 : 00 : 06.130 -> 00 : 00 : 09.311
이제 좀 더 간결한 예제를 사용해 봅시다.

4
00 : 00 : 09.311 -> 00 : 00 : 13.990
이제 이 계산 그래프를 사용하여 
함수 J의 미분값을 계산하는 방법을 

5
00 : 00 : 13.990 -> 00 : 00 : 15.252
설명해 드리겠습니다.

6
00 : 00 : 15.252 -> 00 : 00 : 17.292
이것은 계산 그래프 입니다.

7
00 : 00 : 17.292 -> 00 : 00 : 22.280
v에 대해 J의 미분값을 계산한다고 가정 해 봅시다.

8
00 : 00 : 23.440 -> 00 : 00 : 24.126
이게 무슨 말일까요?

9
00 : 00 : 24.126 -> 00 : 00 : 27.800
그것은 우리가 v의 값을 아주 조금 변화 시켰을때,

10
00 : 00 : 27.800 -> 00 : 00 : 32.360
J의 값이 어떻게 변할 것인가? 라는 의문입니다.

11
00 : 00 : 32.360 -> 00 : 00 : 37.553
J는 v의 3배로 정의합니다.

12
00 : 00 : 37.553 -> 00 : 00 : 42.895
이제 v는 11과 같습니다.

13
00 : 00 : 42.895 -> 00 : 00 : 48.348
그래서 우리가 v를 11.001로 약간 늘리면

14
00 : 00 : 48.348 -> 00 : 00 : 52.524
그렇다면 J값은 33 에서.

15
00 : 00 : 52.524 -> 00 : 00 : 56.130
33.003으로 증가할 겁니다.

16
00 : 00 : 56.130 -> 00 : 00 : 59.123
여기서 우리는 v를 0.001만큼 증가 시켰습니다.

17
00 : 00 : 59.123 -> 00 : 01 : 03.640
그 결과 J가 0.001의 3배 만큼 증가 했습니다.

18
00 : 01 : 03.640 -> 00 : 01 : 08.099
따라서 v에 대한 J의 미분 값은 3입니다.

19
00 : 01 : 08.099 -> 00 : 01 : 12.590
J의 증가분은 v의 증가분의 3 배 이기 때문이죠.

20
00 : 01 : 12.590 -> 00 : 01 : 18.221
사실 이것은 이전 비디오의 예와 매우 유사합니다.

21
00 : 01 : 18.221 -> 00 : 01 : 24.670
이전 비디오에서 보았던, f (a) = 3a 에서

22
00 : 01 : 24.670 -> 00 : 01 : 30.765
우리는 미분값 df(a) / da 을 유도합니다.

23
00 : 01 : 30.765 -> 00 : 01 : 36.740
그냥 약식으로 df / da = 3 이라고 쓰겠습니다.

24
00 : 01 : 36.740 -> 00 : 01 : 41.829
현재 예제로 돌아가서 J = 3v가됩니다.

25
00 : 01 : 41.829 -> 00 : 01 : 44.825
그래서 dJ / dv = 3 이 될겁니다.

26
00 : 01 : 44.825 -> 00 : 01 : 51.713
여기에서 J는 앞의 예제에서 f와 같습니다.

27
00 : 01 : 51.713 -> 00 : 01 : 58.323
그리고 v는 a와 같습니다.

28
00 : 01 : 58.323 -> 00 : 02 : 03.595
결국, back propagation은

29
00 : 02 : 03.595 -> 00 : 02 : 09.617
당신이 가장 신경을 쓰는 변수인

30
00 : 02 : 09.617 -> 00 : 02 : 13.475
최종 출력 변수(J)의 v에 대한 미분값을 계산하는 것 입니다.

31
00 : 02 : 13.475 -> 00 : 02 : 18.790
그리고 이것이 바로 back propagation의 첫번째 단계 입니다.

32
00 : 02 : 18.790 -> 00 : 02 : 22.240
그리고 그래프 상에서 이 과정을 
one step backwards 라고 합니다.

33
00 : 02 : 22.240 -> 00 : 02 : 24.280
이제 다른 예제를 살펴 보겠습니다.

34
00 : 02 : 24.280 -> 00 : 02 : 28.180
dJ / da 란 무엇입니까?

35
00 : 02 : 28.180 -> 00 : 02 : 33.670
다시 말해서 우리가 a의 값을 증가시킨다면
J의 값은 어떻게 변할 것입니까?

36
00 : 02 : 35.420 -> 00 : 02 : 39.965
이 예제를 자세히 살펴 보겠습니다, 
a = 5 라고 놓겠습니다.

37
00 : 02 : 39.965 -> 00 : 02 : 42.850
이 a를 5.001로 늘립니다.

38
00 : 02 : 42.850 -> 00 : 02 : 48.790
그 결과는 v가 a + u 였기 때문에 이전에 11이었지만,

39
00 : 02 : 48.790 -> 00 : 02 : 52.359
지금 11.001로 증가 될겁니다.

40
00 : 02 : 52.359 -> 00 : 02 : 57.224
그러면 앞의 예제에서 보았 듯이

41
00 : 02 : 57.224 -> 00 : 03 : 01.672
J는 33에서 33.003으로 증가합니다.

42
00 : 03 : 01.672 -> 00 : 03 : 07.591
여러분이 a를 0.001만큼 증가 시키면,
J는 0.003만큼 증가 한다는걸 볼 수 있습니다.

43
00 : 03 : 07.591 -> 00 : 03 : 11.751
제가 앞에서 말한 증가의 의미는 
원래 값 인 5에 기초하여

44
00 : 03 : 11.751 -> 00 : 03 : 14.100
새로운 값을 추가 하라는 걸 의미 합니다.

45
00 : 03 : 14.100 -> 00 : 03 : 17.954
그러면 a의 변화가 계산 그래프의 오른쪽으로 전파됩니다.

46
00 : 03 : 17.954 -> 00 : 03 : 19.832
결과 J는 33.003이됩니다.

47
00 : 03 : 19.832 -> 00 : 03 : 28.110
따라서 J 증가분은 a 증가분의 3 배입니다.

48
00 : 03 : 28.110 -> 00 : 03 : 31.520
이것은 J에서 a까지의 미분 값이 
3이라는 것을 의미합니다.

49
00 : 03 : 31.520 -> 00 : 03 : 37.400
그리고 이 문제를 정리해서 말하자면 
a를 변경하면

50
00 : 03 : 37.400 -> 00 : 03 : 38.910
v가 변경된다는 것이고,

51
00 : 03 : 40.130 -> 00 : 03 : 43.967
v가 변하면, J도 변하게 됩니다.

52
00 : 03 : 43.967 -> 00 : 03 : 49.554
그래서 당신이 a를 조금씩 증가시키는 것과 같이
그래프 안의 값을 변화 시킨다면,

53
00 : 03 : 49.554 -> 00 : 03 : 54.313
그것은 J함수의 최종 결과를 
변하게 만드는 것입니다.

54
00 : 03 : 57.699 -> 00 : 04 : 02.561
첫째, a값의 변화가 있기 때문에,
이는 결국 v값을 증가 시킵니다.

55
00 : 04 : 02.561 -> 00 : 04 : 05.850
그럼 v의 값은 얼마나 증가합니까?

56
00 : 04 : 05.850 -> 00 : 04 : 11.709
v의 증가는 dv / da에 달려 있습니다.

57
00 : 04 : 11.709 -> 00 : 04 : 19.802
그리고 v가 바뀌면 J의 값도 증가시킬 겁니다.

58
00 : 04 : 19.802 -> 00 : 04 : 27.064
이것은 미적분학에서 chain rule 이라고 합니다.

59
00 : 04 : 27.064 -> 00 : 04 : 32.023
a는 v에 영향을 주고 v는 다시 J에 영향을 줍니다.


60
00 : 04 : 32.023 -> 00 : 04 : 36.866
그리고 당신이 a를 조금 증가시켰을때 변화되는 J의 총량은

61
00 : 04 : 36.866 -> 00 : 04 : 42.165
(a를 조금 증가시킬때 변화되는 v양) 곱하기 
(v를 조금 증가시킬때 변화되는 J양)입니다.

62
00 : 04 : 42.165 -> 00 : 04 : 46.225
다시, 미적분학에서 이것을 체인 규칙이라고 부릅니다.

63
00 : 04 : 46.225 -> 00 : 04 : 52.140
이 예제에서 a가 0.001만큼 증가했고

64
00 : 04 : 52.140 -> 00 : 04 : 55.250
v 또한 0.001만큼 증가해서

65
00 : 04 : 55.250 -> 00 : 04 : 59.650
그래서 dv / da = 1 이었습니다.

66
00 : 04 : 59.650 -> 00 : 05 : 07.774
사실, 이전 수식을 가져와서,

67
00 : 05 : 07.774 -> 00 : 05 : 11.700
Dv / dJ = 3, dv / da = 1

68
00 : 05 : 11.700 -> 00 : 05 : 14.160
이 두개의 값을 곱하면 3 X 1입니다.

69
00 : 05 : 14.160 -> 00 : 05 : 18.350
이 결과는 3으로 정확히 dJ / da과 
동일한 결과입니다.

70
00 : 05 : 18.350 -> 00 : 05 : 24.963
이 작은 박스는 dJ / dv를 계산하는 방법을 보여줍니다.

71
00 : 05 : 24.963 -> 00 : 05 : 30.183
이 변수와 관계 있는 미분은

72
00 : 05 : 30.183 -> 00 : 05 : 34.030
당신이 dJ / da를 계산할 수 있도록 도와줍니다.

73
00 : 05 : 34.030 -> 00 : 05 : 37.270
이것이 backward calculation의 또 다른 step 입니다.

74
00 : 05 : 39.900 -> 00 : 05 : 44.115
저는 새로운 표기법을 하나 더 
소개해 드리고자 합니다. 

75
00 : 05 : 44.115 -> 00 : 05 : 50.005
backpropagation을 동작시킬 코드를 작성할 때

76
00 : 05 : 50.005 -> 00 : 05 : 54.675
당신이 정말로 신경 쓰고, 또는 최적화 하고 싶어하는

77
00 : 05 : 54.675 -> 00 : 06 : 01.065
최종 출력 변수가 있을 겁니다.

78
00 : 06 : 01.065 -> 00 : 06 : 04.100
이 예에서 최종 출력 변수는 J입니다.

79
00 : 06 : 04.100 -> 00 : 06 : 07.460
이것은 계산 그래프의 마지막 노드 이기도 합니다.

80
00 : 06 : 07.460 -> 00 : 06 : 11.870
그리고 많은 계산식 들은 이 최종 출력 변수의

81
00 : 06 : 11.870 -> 00 : 06 : 13.343
미분 값을 계산 하려고 할 것입니다.

82
00 : 06 : 13.343 -> 00 : 06 : 17.100
즉, 다른 변수에 대한 최종 출력 변수의 미분을 

83
00 : 06 : 17.100 -> 00 : 06 : 23.319
우리는 그것을 d final output / d var라고 부르겠습니다.

84
00 : 06 : 23.319 -> 00 : 06 : 27.909
최종 출력 변수 의 미분을
(이 예 에서는 J가 되겠군요)

85
00 : 06 : 27.909 -> 00 : 06 : 32.164
a b c u v 와 같은 많은 다른 변수들에 대해서

86
00 : 06 : 32.164 -> 00 : 06 : 34.520
계산을 수행 하도록 해야합니다.

87
00 : 06 : 34.520 -> 00 : 06 : 41.280
그럼 여러분이 프로그램에서 이걸 구현할 때 
이러한 변수의 이름을 무엇 이라고 할겁니까?

88
00 : 06 : 41.280 -> 00 : 06 : 44.208
파이썬에서는

89
00 : 06 : 44.208 -> 00 : 06 : 50.280
dFinalOutputVar / dvar 라는 긴 이름으로 쓰여집니다.

90
00 : 06 : 50.280 -> 00 : 06 : 51.766
그러나 이것은 너무 깁니다.

91
00 : 06 : 51.766 -> 00 : 06 : 55.018
당신은 dJdvar를 이용해도 이를 
호출 할 수 있습니다.

92
00 : 06 : 55.018 -> 00 : 06 : 58.929
그러나 당신은 항상 최종 출력 변수인 
dJ에 대한 미분값을 계산하기 때문에

93
00 : 06 : 58.929 -> 00 : 07 : 03.173
나는 새로운 표기법을 소개 하고 싶습니다.

94
00 : 07 : 03.173 -> 00 : 07 : 09.635
코드에서 이 미분을 계산할 때

95
00 : 07 : 09.635 -> 00 : 07 : 16.936
이 값을 나타 내기 위해 변수 이름 dvar를 사용합니다.

96
00 : 07 : 16.936 -> 00 : 07 : 21.459
따라서 코드에 포현된 dvar는

97
00 : 07 : 21.459 -> 00 : 07 : 25.444
J와 같은 최종 출력 변수의 미분 값을 표현 합니다.

98
00 : 07 : 25.444 -> 00 : 07 : 29.938
음, J가 아니라 때로는 Loss함수 L이 될 수도 있겠죠.
물론, 이들은 중간 매개 변수들과 관련되 있을 겁니다.

99
00 : 07 : 29.938 -> 00 : 07 : 31.795
코드에서 이를 사용 할 때는

100
00 : 07 : 31.795 -> 00 : 07 : 38.380
이 값을 나타 내기 위해 dv를 사용하십시오.

101
00 : 07 : 38.380 -> 00 : 07 : 42.453
그러니까 Dv = 3 이 될 겁니다.

102
00 : 07 : 42.453 -> 00 : 07 : 46.635
그리고 이 값은 코드에서 
da를 사용하여 나타냅니다.

103
00 : 07 : 46.635 -> 00 : 07 : 51.185
Da는 또한 3과 같습니다.

104
00 : 07 : 51.185 -> 00 : 07 : 58.018
이 계산 그래프를 통해 우리는 
backpropagation의 일부를 해봤습니다.

105
00 : 07 : 58.018 -> 00 : 08 : 02.130
다음 슬라이드에서이 예제를 계속 진행할 것입니다.

106
00 : 08 : 02.130 -> 00 : 08 : 06.293
슬라이드를 깔끔하게 만들어 보겠습니다.

107
00 : 08 : 06.293 -> 00 : 08 : 09.846
그리고 복습해보죠,

108
00 : 08 : 09.846 -> 00 : 08 : 14.743
우리가 했던거는 여기서 역으로 계산해서 
dv = 3인걸 찾은 겁니다.

109
00 : 08 : 14.743 -> 00 : 08 : 18.783
Dv는 단지 변수 이름입니다.

110
00 : 08 : 18.783 -> 00 : 08 : 20.844
실제로는 dJ / dv를 나타냅니다.

111
00 : 08 : 20.844 -> 00 : 08 : 24.303
우리는 da = 3 이라는걸 계산 했었습니다.

112
00 : 08 : 24.303 -> 00 : 08 : 30.470
위와 같이, da는 코드 상에서 
dJ / da의 변수 이름일 뿐입니다.

113
00 : 08 : 32.332 -> 00 : 08 : 39.410
우리는 이 두 측면에서 backpropagation이 
어떻게 구현되는지 추론했습니다.

114
00 : 08 : 39.410 -> 00 : 08 : 41.262
이제 미분 계산을 계속합시다.

115
00 : 08 : 41.262 -> 00 : 08 : 44.129
이제 u의 값을 봅시다.

116
00 : 08 : 44.129 -> 00 : 08 : 47.473
dJ / du 는 무엇 인가요?

117
00 : 08 : 47.473 -> 00 : 08 : 52.153
이전과 비슷한 계산을 해보죠.

118
00 : 08 : 52.153 -> 00 : 08 : 54.430
u = 6부터 시작 하겠습니다.

119
00 : 08 : 54.430 -> 00 : 08 : 57.913
u가 6에서 6.001로 변경되면

120
00 : 08 : 57.913 -> 00 : 09 : 02.700
v값은 11에서 11.001이 됩니다.

121
00 : 09 : 02.700 -> 00 : 09 : 07.978
J는 33에서 33.003이 되겠군요

122
00 : 09 : 07.978 -> 00 : 09 : 12.190
그래서 J는 u의 증가량의 3 배 증가했습니다.

123
00 : 09 : 12.190 -> 00 : 09 : 16.760
u의 경우는 a의 경우와 매우 유사합니다.

124
00 : 09 : 16.760 -> 00 : 09 : 23.884
dj / dv 와 dv / du를 곱하여 계산할 수 있습니다.

125
00 : 09 : 23.884 -> 00 : 09 : 30.186
우리가 계산 한 이 dj / dv는 3입니다.

126
00 : 09 : 30.186 -> 00 : 09 : 33.800
dv / du는 1로 계산 됩니다.

127
00 : 09 : 33.800 -> 00 : 09 : 36.950
그래서 우리는 backpropagation을 
한단계 더 완료했습니다.

128
00 : 09 : 36.950 -> 00 : 09 : 42.920
우리는 du가 3과 같다는 결론에 도달했습니다.

129
00 : 09 : 42.920 -> 00 : 09 : 47.240
물론 du는 dJ / du를 가리 킵니다.

130
00 : 09 : 47.240 -> 00 : 09 : 51.570
이제 마지막 예제를 주의 깊게 계산 해봅시다.

131
00 : 09 : 51.570 -> 00 : 09 : 54.137
dJ / db 란 무엇입니까?

132
00 : 09 : 54.137 -> 00 : 09 : 57.255
b 값을 바꿀 수 있다면 그것에 대해 생각 해보십시오.

133
00 : 09 : 57.255 -> 00 : 10 : 01.585
당신은 b의 값을 변경하여 J의 값을.

134
00 : 10 : 01.585 -> 00 : 10 : 04.040
최소화 하거나 극대화하고 싶을 겁니다.

135
00 : 10 : 04.040 -> 00 : 10 : 05.340
그렇게 b의 값을 약간 변경한다면

136
00 : 10 : 05.340 -> 00 : 10 : 10.860
dJ / db의 미분값이나 함수 J의 기울기는 무엇입니까?

137
00 : 10 : 11.880 -> 00 : 10 : 15.257
계산에 체인 규칙을 사용해 본다면

138
00 : 10 : 15.257 -> 00 : 10 : 18.416
dJ / db는 위와 같은 두 개의 곱셈으로 
쓸 수 있습니다

139
00 : 10 : 18.416 -> 00 : 10 : 24.720
그 이유는 

140
00 : 10 : 24.720 -> 00 : 10 : 30.390
b 값을 약간 변경 해보면,

141
00 : 10 : 30.390 -> 00 : 10 : 34.275
3에서 3.001로

142
00 : 10 : 34.275 -> 00 : 10 : 38.041
최종적으로는 J에 영향을 주겠지만 
우선 u에 영향을 줄겁니다.

143
00 : 10 : 38.041 -> 00 : 10 : 40.120
그러면 U에 어떻게 영향을 줍니까?

144
00 : 10 : 40.120 -> 00 : 10 : 44.100
u는 b 곱하기 c로 정의됩니다.

145
00 : 10 : 44.100 -> 00 : 10 : 48.073
b = 3 일 때, u는 6에서 시작을 합니다.

146
00 : 10 : 48.073 -> 00 : 10 : 53.238
하지만 b가 변한 지금, u는 6.002가된다.

147
00 : 10 : 53.238 -> 00 : 10 : 59.560
왜냐하면 이 예제에서 c = 2로 
고정되어 있기 때문입니다.

148
00 : 10 : 59.560 -> 00 : 11 : 05.150
이걸 통해서 du / db = 2 라는걸 알 수 있습니다.

149
00 : 11 : 05.150 -> 00 : 11 : 10.490
b를 0.001만큼 증가 시키면 
u는 2배로 증가하고 0.002가 증가합니다.

150
00 : 11 : 10.490 -> 00 : 11 : 15.360
그래서 du / db = 2 입니다.

151
00 : 11 : 15.360 -> 00 : 11 : 21.430
이제 우리는 u의 변화가 b의 2 배라는 것을 압니다.

152
00 : 11 : 21.430 -> 00 : 11 : 24.460
dJ / du 는 어떻습니까?

153
00 : 11 : 24.460 -> 00 : 11 : 27.447
우리는 이미 이 값이 3이라고 계산했습니다.

154
00 : 11 : 27.447 -> 00 : 11 : 32.850
따라서 이 두 항목을 곱하면 dJ / db = 6 이됩니다.

155
00 : 11 : 32.850 -> 00 : 11 : 36.274
이 미분의 두 번째 부분을 자세히 봅시다.

156
00 : 11 : 36.274 -> 00 : 11 : 43.370
우리는 u가 0.002 증가 할 때, 
J가 어떻게 변하는 지를 알고 싶었습니다.

157
00 : 11 : 43.370 -> 00 : 11 : 48.746
dJ / du = 3은 우리에게

158
00 : 11 : 48.746 -> 00 : 11 : 54.310
u가 0.002 증가하면 
J는 이 값의 3배 만큼 증가된다는 걸 알려줍니다.

159
00 : 11 : 54.310 -> 00 : 11 : 59.943
그래서 J는 0.006만큼 증가 합니다.

160
00 : 11 : 59.943 -> 00 : 12 : 05.670
이것은 dJ / du = 3이기 때문입니다.

161
00 : 12 : 05.670 -> 00 : 12 : 09.351
수학적인 계산을 조금 해보면

162
00 : 12 : 09.351 -> 00 : 12 : 13.891
b가 3.001이되면

163
00 : 12 : 13.891 -> 00 : 12 : 20.190
u는 6.002가되고 v는 11.002가됩니다.

164
00 : 12 : 20.190 -> 00 : 12 : 24.064
이것은 a + u 라서 5 + u 가 되니까요.

165
00 : 12 : 24.064 -> 00 : 12 : 28.450
그러면 J는 v의 3배니까

166
00 : 12 : 28.450 -> 00 : 12 : 33.101
결과는 33.006입니다.

167
00 : 12 : 33.101 -> 00 : 12 : 37.695
위의 과정은 당신이 dJ / db = 6 라는 
결과를 얻은 과정 입니다.

168
00 : 12 : 37.695 -> 00 : 12 : 43.738
여기서 우리가 다시 역으로 갈 때 db = 6입니다.

169
00 : 12 : 43.738 -> 00 : 12 : 50.347
Db는 Python에서 dJ / db의 변수 이름입니다.

170
00 : 12 : 50.347 -> 00 : 12 : 53.565
그리고 저는 마지막 예는 
자세한 설명을 하지 않을 겁니다.

171
00 : 12 : 53.565 -> 00 : 13 : 00.423
하지만 dJ / dc 를 계산하면

172
00 : 13 : 00.423 -> 00 : 13 : 05.748
이것은 dj / du 곱하기 du / dc입니다.

173
00 : 13 : 05.748 -> 00 : 13 : 09.987
결과는 3 곱하기 3을 해서 9 입니다.

174
00 : 13 : 09.987 -> 00 : 13 : 11.950
나는 이 예를 자세히 설명하지 않을 것입니다.

175
00 : 13 : 11.950 -> 00 : 13 : 18.720
마지막 단계를 통해 dc = 9를 계산할 수 있습니다.

176
00 : 13 : 20.060 -> 00 : 13 : 24.634
이 비디오에서 여러분이 알아야 할 
가장 중요한 점은 

177
00 : 13 : 24.634 -> 00 : 13 : 29.347
모든 미분을 계산할 때 가장 효율적인 방법이

178
00 : 13 : 29.347 -> 00 : 13 : 34.221
빨간색 화살표 방향에 따라 
오른쪽에서 왼쪽으로 계산하는 것이라는 겁니다.

179
00 : 13 : 34.221 -> 00 : 13 : 37.780
특히, 우리는 먼저 v에 대한 미분을 계산 했습니다.

180
00 : 13 : 37.780 -> 00 : 13 : 40.530
v에 대한 미분 값은

181
00 : 13 : 40.530 -> 00 : 13 : 45.410
a 에 대한 미분및 u 에 대한 미분을 계산할 때 유용합니다.

182
00 : 13 : 45.410 -> 00 : 13 : 48.070
그리고 u에 대한 미분 값은

183
00 : 13 : 48.070 -> 00 : 13 : 52.020
여기 이거랑, 또 이거 겠네요

184
00 : 13 : 52.020 -> 00 : 13 : 55.430
애네들은 b에 대한 미분과 

185
00 : 13 : 55.430 -> 00 : 13 : 57.610
c에 대한 미분을 할 때 유용합니다.

186
00 : 13 : 57.610 -> 00 : 14 : 02.370
그래요 이것이 computation graph 입니다.

187
00 : 14 : 02.370 -> 00 : 14 : 07.620
정방향(forward) 계산은 J와 같은 비용 함수를 
최적화 하는데 등에 사용 합니다.

188
00 : 14 : 07.620 -> 00 : 14 : 12.940
그리고 역(backward)계산은 
미분을 계산 하기 위해서 사용합니다.

189
00 : 14 : 12.940 -> 00 : 14 : 15.422
당신이 미분 또는 chain rule에 익숙하지 않은 경우

190
00 : 14 : 15.422 -> 00 : 14 : 18.382
저는 위에서 배운 세부내용들이 
금방 머리속에서 사라질 거라고 생각합니다.

191
00 : 14 : 18.382 -> 00 : 14 : 21.500
이러한 세부 사항을 기억하지 못해도 걱정하지 마십시오.

192
00 : 14 : 21.500 -> 00 : 14 : 22.567
다음 비디오에서,

193
00 : 14 : 22.567 -> 00 : 14 : 26.251
우리는 로지스틱 회귀를 적용해서 이 내용을 다시 얘기할 겁니다.
그리고 로지스틱 회귀 모델의 미분을 계산하는데 

194
00 : 14 : 26.251 -> 00 : 14 : 30.337
필요한 계산을 구현하기 위해 수행해야 할

195
00 : 14 : 30.337 -> 00 : 14 : 33.780
작업을 정확하게 보여줍니다.