WEBVTT

1
00 : 00 : 00.210 -> 00 : 00 : 03.240
이전 동영상에서
broadcasting이라는 기술을 사용하면

2
00 : 00 : 03.240 -> 00 : 00 : 07.040
Python 코드의 실행 속도를
빠르게 할 수 있다고했습니다

3
00 : 00 : 07.040 -> 00 : 00 : 11.860
이 동영상은 Python으로 broadcasting을
어떻게 동작시키는 해보겠습니다.

4
00 : 00 : 11.860 -> 00 : 00 : 14.240
broadcasting
예를 살펴 봅시다.

5
00 : 00 : 14.240 -> 00 : 00 : 18.730
이 행렬은 4 종류의 음식에서
100 그램 당 칼로리를

6
00 : 00 : 18.730 -> 00 : 00 : 22.320
탄수화물, 단백질
지방에 따라 따로 표시했습니다

7
00 : 00 : 22.320 -> 00 : 00 : 25.380
예를 들어 100 그램의 사과의 칼로리는

8
00 : 00 : 25.380 -> 00 : 00 : 29.690
탄수화물에서 56 칼로리로
단백질과 지방 에서는 상당히 적습니다

9
00 : 00 : 29.690 -> 00 : 00 : 35.110
반면 쇠고기는 단백질에서 104 칼로리
지방 에서는

10
00 : 00 : 35.110 -> 00 : 00 : 37.620
135 칼로리입니다

11
00 : 00 : 37.620 -> 00 : 00 : 43.330
여기에서의 목표는 4 종류의 식품의
탄수화물, 단백질, 지방에서의

12
00 : 00 : 43.330 -> 00 : 00 : 48.440
칼로리의 비율을
계산하는것 이라고 합시다

13
00 : 00 : 48.440 -> 00 : 00 : 52.338
예를 들어이 행을 살펴보면

14
00 : 00 : 52.338 -> 00 : 00 : 57.697
이 열의 수를 더해 가면
100 그램의 사과는

15
00 : 00 : 57.697 -> 00 : 01 : 02.580
56 + 1.2 + 1.8
59 칼로리를 가진걸 알 수 있습니다.

16
00 : 01 : 02.580 -> 00 : 01 : 06.806
그리고 사과의

17
00 : 01 : 06.806 -> 00 : 01 : 11.800
탄수화물의 전체에 대한 칼로리 비율은
56 / 59 로

18
00 : 01 : 11.800 -> 00 : 01 : 16.932
약 94.9 %입니다

19
00 : 01 : 16.932 -> 00 : 01 : 22.399
사과의 칼로리는
대부분이 탄수화물에서 오는 거네요.

20
00 : 01 : 22.399 -> 00 : 01 : 27.630
반면 쇠고기 칼로리는 대부분
단백질과 지방에서 오는군요.

21
00 : 01 : 27.630 -> 00 : 01 : 33.630
이를 위해서는
이 행렬의 4 개의 열을 각각 합계하여

22
00 : 01 : 33.630 -> 00 : 01 : 38.740
100 그램의 사과 쇠고기, 
계란, 감자의 총 열량을

23
00 : 01 : 38.740 -> 00 : 01 : 40.920
계산 합니다.

24
00 : 01 : 40.920 -> 00 : 01 : 45.090
그리고 각 영양소의 칼로리에서
계산한 행렬을 나눠줌 으로써

25
00 : 01 : 47.230 -> 00 : 01 : 51.230
4개 식품의 탄수화물, 단백질, 지방
비율을 %로

26
00 : 01 : 51.230 -> 00 : 01 : 54.870
나타낼 수 있습니다.

27
00 : 01 : 54.870 -> 00 : 02 : 01.370
여기서 의문은 for loop를 작성하지 않고
이것을 할 수 있냐는 것입니다.

28
00 : 02 : 01.370 -> 00 : 02 : 03.290
어떻게하는지 살펴 봅시다.

29
00 : 02 : 04.450 -> 00 : 02 : 08.602
지금부터 보여드리죠.

30
00 : 02 : 08.602 -> 00 : 02 : 12.990
이 행렬을 3x4의 행렬 A로 놓겠습니다.

31
00 : 02 : 12.990 -> 00 : 02 : 18.300
그리고 한 줄의 Python 코드를 이용해서
각 열의 값을 합계합니다

32
00 : 02 : 18.300 -> 00 : 02 : 22.078
그래서 우리는 4 개의 식품 칼로리의 
합계에 해당하는

33
00 : 02 : 22.078 -> 00 : 02 : 25.046
4 개의 숫자를 계산합니다

34
00 : 02 : 25.046 -> 00 : 02 : 28.095
4 종류의 음식
100 그램당 총 칼로리 입니다.

35
00 : 02 : 28.095 -> 00 : 02 : 32.113
그리고 두 번째 줄의 Python 코드를 사용하여

36
00 : 02 : 32.113 -> 00 : 02 : 35.390
그 열의 합계에 해당하는 숫자로
컬럼에서 숫자를 나눕니다

37
00 : 02 : 35.390 -> 00 : 02 : 37.250
말로 설명이 충분하지 않다면

38
00 : 02 : 37.250 -> 00 : 02 : 40.670
앞으로 볼 Python의 코드를 보면
알기 쉽다고 생각합니다

39
00 : 02 : 40.670 -> 00 : 02 : 42.460
Jupyter Notebook에 들어 왔습니다

40
00 : 02 : 42.460 -> 00 : 02 : 46.150
칼로리 표를
행렬 A에 넣기 위한 첫 번째 코드는

41
00 : 02 : 46.150 -> 00 : 02 : 49.860
제가 써 두었습니다.
shift + enter로 실행해보면,

42
00 : 02 : 49.860 -> 00 : 02 : 51.220
이렇게 행렬 A가 나와 있습니다

43
00 : 02 : 51.220 -> 00 : 02 : 55.080
여기에 두 줄의 Python 코드를 넣습니다

44
00 : 02 : 55.080 -> 00 : 02 : 59.983
우선 cal = A.sum (axis = 0)를 씁니다.

45
00 : 02 : 59.983 -> 00 : 03 : 02.280
axis = 0은 세로로 더하라는 의미입니다.

46
00 : 03 : 02.280 -> 00 : 03 : 05.280
이에 대해서는 곧 더 자세한 이야기를 하겠습니다.

47
00 : 03 : 05.280 -> 00 : 03 : 06.076
cal을 print합니다

48
00 : 03 : 06.076 -> 00 : 03 : 07.825
세로로 합계를 한 것이 보일겁니다.

49
00 : 03 : 07.825 -> 00 : 03 : 13.735
59가 사과의 총 칼로리

50
00 : 03 : 13.735 -> 00 : 03 : 19.575
239이 쇠고기의 총 칼로리
계란, 감자 계속됩니다

51
00 : 03 : 19.575 -> 00 : 03 : 25.151
다음 percentge를 계산합니다

52
00 : 03 : 25.151 -> 00 : 03 : 30.733
A / cal.reshape (1,4) 라고 쓰고,

53
00 : 03 : 30.733 -> 00 : 03 : 33.927
백분율로 나와야 되니까 
100을 여기에 곱하겠습니다. 

54
00 : 03 : 35.913 -> 00 : 03 : 38.860
percentage를 print합시다

55
00 : 03 : 40.800 -> 00 : 03 : 41.950
실행합시다.

56
00 : 03 : 41.950 -> 00 : 03 : 46.870
이 명령은 행렬 A를

57
00 : 03 : 46.870 -> 00 : 03 : 50.820
여기있는 1x4 행렬인 cal로 나눈다는 뜻입니다.

58
00 : 03 : 50.820 -> 00 : 03 : 52.672
이제 행렬의 퍼센트가 나와 있습니다

59
00 : 03 : 52.672 -> 00 : 03 : 57.327
손으로 계산 한 것처럼
첫 번째 열의 사과의 칼로리는

60
00 : 03 : 57.327 -> 00 : 04 : 02.480
94.9 %가 탄수화물에서 나옵니다.

61
00 : 04 : 02.480 -> 00 : 04 : 04.000
슬라이드로 돌아 갑시다.

62
00 : 04 : 04.000 -> 00 : 04 : 06.310
사용한 두 줄의 코드를 되돌아 봅니다

63
00 : 04 : 06.310 -> 00 : 04 : 09.940
이것이 Jupyter Notebook에
쓴 것입니다

64
00 : 04 : 09.940 -> 00 : 04 : 13.306
조금 자세히 설명하면
이 매개 변수 (axis = 0)은

65
00 : 04 : 13.306 -> 00 : 04 : 18.540
Python에서 세로 방향으로의 총 합계를
의미합니다

66
00 : 04 : 18.540 -> 00 : 04 : 21.567
axis 0은
세로로 더한다는 뜻이고

67
00 : 04 : 21.567 -> 00 : 04 : 24.029
한편 axis 1
옆으로 더한다는 뜻 입니다

68
00 : 04 : 24.029 -> 00 : 04 : 28.050
axis 1이라고 쓰면
세로가 아닌 가로로 더한다는 뜻입니다.

69
00 : 04 : 28.050 -> 00 : 04 : 30.670
다음 명령은

70
00 : 04 : 30.670 -> 00 : 04 : 35.210
Python broadcasting의 예입니다

71
00 : 04 : 35.210 -> 00 : 04 : 43.330
행렬 A는 3x4의 행렬로
이를 1x4 행렬로 나눕니다

72
00 : 04 : 43.330 -> 00 : 04 : 47.370
사실 첫 번째 줄의 코드를 실행 한 후에는
변수 cal은

73
00 : 04 : 47.370 -> 00 : 04 : 49.590
이미 1x4 행렬이 되어 있습니다

74
00 : 04 : 49.590 -> 00 : 04 : 52.616
그래서 이 reshape(1, 4)을
다시 쓸 필요는 없습니다

75
00 : 04 : 52.616 -> 00 : 04 : 54.722
사실 약간 중복이지만

76
00 : 04 : 54.722 -> 00 : 04 : 59.140
저는 Python 코드를 작성할 때

77
00 : 04 : 59.140 -> 00 : 05 : 04.056
행렬의 배열 수를 모를 때는
reshape 명령을 수행 하도록 합니다.

78
00 : 05 : 04.056 -> 00 : 05 : 07.833
행과 열 벡터를
확실히 원하는 형태로 만들기 위해서

79
00 : 05 : 07.833 -> 00 : 05 : 09.500
이 명령을 하고 있습니다

80
00 : 05 : 09.500 -> 00 : 05 : 11.840
reshape 명령은
계속해서 사용 할 수있는 것입니다

81
00 : 05 : 11.840 -> 00 : 05 : 15.150
처리량에 대한 일차적 인 명령이므로
호출하는 조건도 매우 간단합니다.

82
00 : 05 : 15.150 -> 00 : 05 : 18.404
reshape을 사용하는걸 부끄러워 하지 말고,
행렬이 원하는 크기가 될 것을 보장하기 위해

83
00 : 05 : 18.404 -> 00 : 05 : 20.830
적극적으로 사용합시다.

84
00 : 05 : 21.920 -> 00 : 05 : 27.272
이제 이러한 명령이 어떻게 작동 하는지를
자세히 설명합니다

85
00 : 05 : 27.272 -> 00 : 05 : 33.780
우리는 3x4 행렬을
1x4 행렬로 나눴습니다.

86
00 : 05 : 33.780 -> 00 : 05 : 37.840
어떻게하여 3x4을
1x4 벡터로

87
00 : 05 : 37.840 -> 00 : 05 : 38.860
나눌수 있는 것입니까?

88
00 : 05 : 40.130 -> 00 : 05 : 43.160
broadcasting의 예를
좀 더 살펴 봅시다.

89
00 : 05 : 43.160 -> 00 : 05 : 47.920
4x1 벡터에
100을 더하면

90
00 : 05 : 47.920 -> 00 : 05 : 53.011
Python은 자동으로

91
00 : 05 : 53.011 -> 00 : 05 : 58.180
100을 4x1 벡터로
확장합니다

92
00 : 05 : 58.180 -> 00 : 06 : 00.257
벡터 [1,2,3,4]에

93
00 : 06 : 00.257 -> 00 : 06 : 04.450
[100,100,100,100]을 더하면
오른쪽의 벡터가 완성됩니다

94
00 : 06 : 04.450 -> 00 : 06 : 09.280
100을 모든 요소에 더하는
이 형태의 broadcasting은

95
00 : 06 : 09.280 -> 00 : 06 : 14.365
이전의 동영상에서는
상수 b에도 적용되고 있었습니다.

96
00 : 06 : 14.365 -> 00 : 06 : 19.414
이 형태의 broadcasting은
열 벡터와 행 벡터 모두에서 작동합니다

97
00 : 06 : 19.414 -> 00 : 06 : 24.157
사실 위에서도 말했듯이 우리는 이미 
이와 같은 형태의 broadcasting을 적용했습니다.

98
00 : 06 : 24.157 -> 00 : 06 : 29.330
로지스틱 회귀에서
더해지는 상수 b에서 말이죠.

99
00 : 06 : 29.330 -> 00 : 06 : 31.610
또 다른 예입니다.

100
00 : 06 : 31.610 -> 00 : 06 : 35.900
2x3 행렬과 1xn 벡터가

101
00 : 06 : 35.900 -> 00 : 06 : 39.420
더해지는 경우입니다

102
00 : 06 : 40.950 -> 00 : 06 : 45.682
일반화하면

103
00 : 06 : 45.682 -> 00 : 06 : 50.583
(m, n) 행렬을

104
00 : 06 : 50.583 -> 00 : 06 : 55.330
(1, n) 행렬에 더하는 경우 입니다.

105
00 : 06 : 55.330 -> 00 : 06 : 58.667
Python이 하는 것은
(1, n) 행렬을

106
00 : 06 : 58.667 -> 00 : 07 : 03.672
m 개 복사해서
mxn 행렬로 만듭니다.

107
00 : 07 : 03.672 -> 00 : 07 : 09.980
1x3 행렬을 복사하여
이런 식으로 만듭니다.

108
00 : 07 : 09.980 -> 00 : 07 : 14.092
그래서 2x3 행렬의 형태가 됩니다

109
00 : 07 : 14.092 -> 00 : 07 : 18.270
그 후에 합을 하게 되면
오른쪽의 결과나 나옵니다.

110
00 : 07 : 18.270 -> 00 : 07 : 21.583
첫 번째 열에 100이 더해졌고

111
00 : 07 : 21.583 -> 00 : 07 : 25.812
두 번째 열에 200
세 번째 열에 300이 더해졌습니다.

112
00 : 07 : 25.812 -> 00 : 07 : 28.796
이것은 이전 슬라이드에서
했던 것과 거의 동일합니다

113
00 : 07 : 28.796 -> 00 : 07 : 32.810
아까는 나눗셈 명령 이었지만
이번에는 더하기 명령이라는 것만 빼면 말이죠.

114
00 : 07 : 34.180 -> 00 : 07 : 40.402
마지막으로 또 하나의 예입니다
mxn 행렬에

115
00 : 07 : 40.402 -> 00 : 07 : 46.260
mx1의 행렬을 더할 경우
어떻게 해야할까요?

116
00 : 07 : 47.310 -> 00 : 07 : 50.760
이것이 n번 수평으로 복사가 될것이고,

117
00 : 07 : 50.760 -> 00 : 07 : 53.510
mxn 행렬로 만들어질 겁니다.

118
00 : 07 : 53.510 -> 00 : 07 : 56.990
옆에 3 개의 열이될 때까지 복사됩니다

119
00 : 07 : 56.990 -> 00 : 07 : 58.650
그리고 더하게 되면

120
00 : 07 : 58.650 -> 00 : 08 : 01.070
이 같은 결과가됩니다

121
00 : 08 : 01.070 -> 00 : 08 : 06.890
첫 번째 줄에 100을 더해
두 번째 줄에 200을 더합니다

122
00 : 08 : 08.270 -> 00 : 08 : 12.061
Python broadcasting의 기본 원칙들을
소개합니다

123
00 : 08 : 12.061 -> 00 : 08 : 17.353
(m, n) 행렬이

124
00 : 08 : 17.353 -> 00 : 08 : 24.409
(1, n) 행렬과 덧셈, 뺄셈
곱하기, 나누기를 할 때

125
00 : 08 : 24.409 -> 00 : 08 : 31.177
m개 만큼 복사되어
(m, n)의 행렬을 만듭니다

126
00 : 08 : 31.177 -> 00 : 08 : 33.781
그리고 그 element마다
더하기, 빼기

127
00 : 08 : 33.781 -> 00 : 08 : 36.140
곱하기, 나누기를
적용합니다

128
00 : 08 : 37.250 -> 00 : 08 : 42.250
만약 반대로 (m, n) 행렬과
(m, 1) 행렬을

129
00 : 08 : 42.250 -> 00 : 08 : 49.060
연산한다면
이 경우에는 n 번 복사되어

130
00 : 08 : 49.060 -> 00 : 08 : 54.740
(m, n) 행렬이 됩니다.
그리고 역시 element마다 계산을 적용합니다

131
00 : 08 : 54.740 -> 00 : 09 : 00.327
다른 broadcasting을 소개합니다
(m, 1)의 행렬이 있다고합니다

132
00 : 09 : 00.327 -> 00 : 09 : 05.175
이건 예를 들면, 
열 벡터 [1,2,3] 같은 것이 되겠군요

133
00 : 09 : 05.175 -> 00 : 09 : 08.482
이에 실수(Real number)를 더하기, 빼기
곱하기, 나누기하면

134
00 : 09 : 08.482 -> 00 : 09 : 11.080
실수는 (1,1)의 행렬이니까

135
00 : 09 : 11.080 -> 00 : 09 : 16.117
플러스 100을 한다고 하면
이 실수 100을

136
00 : 09 : 16.117 -> 00 : 09 : 23.512
m개 만큼 복사해서
(m, 1)의 행렬이 될 때까지 복사합니다

137
00 : 09 : 23.512 -> 00 : 09 : 29.700
거기에 여기있는 예와 같이
연산을 수행합니다

138
00 : 09 : 29.700 -> 00 : 09 : 35.823
행 벡터에 대해서도
같은 방식으로 작동합니다

139
00 : 09 : 38.281 -> 00 : 09 : 43.730
만약 완벽하게 일반화된 broadcasting을 사용하면
이거보다 좀 더 많은 역할을 할 수 있습니다.

140
00 : 09 : 43.730 -> 00 : 09 : 49.080
만약 관심이 있다면
numpy 자료를 읽고

141
00 : 09 : 49.080 -> 00 : 09 : 52.240
그 자료에 있는 broadcasting을
보면될 겁니다.

142
00 : 09 : 52.240 -> 00 : 09 : 56.380
보다 일반적인 broadcasting의 정의가
써 있습니다

143
00 : 09 : 56.380 -> 00 : 10 : 00.140
하지만 이 슬라이드에 써있는 형태의 것 정도가
신경망을 구현하는 경우에

144
00 : 10 : 00.140 -> 00 : 10 : 02.560
필요한 것들 입니다

145
00 : 10 : 03.890 -> 00 : 10 : 06.840
마무리 하기 전에
마지막에 한마디만 하겠습니다.

146
00 : 10 : 06.840 -> 00 : 10 : 10.210
당신이 Matlab과 Octave에서
프로그램에 익숙해져 있는 사람이고

147
00 : 10 : 10.210 -> 00 : 10 : 15.760
신경망 프로그램을 구현하는데 
bsxfun을 사용한 적이 있다면

148
00 : 10 : 15.760 -> 00 : 10 : 20.590
bsxfun은 완전히 같지는 않지만 
python과 비슷한 움직임을 합니다

149
00 : 10 : 20.590 -> 00 : 10 : 25.750
bsxfun은 Python에서의
broadcasting과 같은 목적으로 사용됩니다

150
00 : 10 : 25.750 -> 00 : 10 : 28.505
물론 이 정보는
Matlab과 Octave에

151
00 : 10 : 28.505 -> 00 : 10 : 31.600
능숙한 사용자를 위한 것입니다
들어 본 적이 없어도 걱정하지 마십시오

152
00 : 10 : 31.600 -> 00 : 10 : 35.524
Python으로 코드를 짤때는
알 필요가 없는 것들 입니다.

153
00 : 10 : 35.524 -> 00 : 10 : 38.720
정리하면 이것이 Python에서의
broadcasting입니다

154
00 : 10 : 38.720 -> 00 : 10 : 42.360
당신이 프로그램 과제를
할 때 broadcasting을 사용하여

155
00 : 10 : 42.360 -> 00 : 10 : 44.580
코드를 빠르게 작동시킬뿐만 아니라

156
00 : 10 : 44.580 -> 00 : 10 : 48.920
더 적은 코드를 이용하여
실시 할 수 있게 도움이 되었으면합니다

157
00 : 10 : 50.360 -> 00 : 10 : 53.630
프로그램 연습을 시작하기 전에
하나 공유하고 싶은 것이 있습니다.

158
00 : 10 : 53.630 -> 00 : 10 : 56.290
Python 코드의

159
00 : 10 : 56.290 -> 00 : 11 : 00.700
버그를 줄이는 요령입니다

160
00 : 11 : 00.700 -> 00 : 11 : 02.640
이것이 도움이라고 생각합니다

161
00 : 11 : 02.640 -> 00 : 11 : 05.550
나머지는 다음 비디오에서 이야기합시다.