WEBVTT

1
00 : 00 : 00.860 -> 00 : 00 : 05.760
지금까지는 벡터화에 의해 코드의 실행 속도를 
더 빠르게 할 수 있음을 보고 왔습니다

2
00 : 00 : 05.760 -> 00 : 00 : 08.160
이 비디오에서는 로지스틱 회귀를

3
00 : 00 : 08.160 -> 00 : 00 : 10.545
벡터화하는 방법을 말해보겠습니다.

4
00 : 00 : 10.545 -> 00 : 00 : 12.960
이는 학습 데이터 전체를
처리 할 수 있도록 해줍니다.

5
00 : 00 : 12.960 -> 00 : 00 : 15.930
여기에서는 하나도 for loop를 쓰지 않고

6
00 : 00 : 15.930 -> 00 : 00 : 22.330
학습 데이터 전체의 경사 강하 법의 실행을
한번의 실행으로 완료 할 수 있도록 구현합니다

7
00 : 00 : 22.330 -> 00 : 00 : 24.039
이 기법 처럼

8
00 : 00 : 24.039 -> 00 : 00 : 26.670
하나의 for loop조차도
사용하지 않은

9
00 : 00 : 26.670 -> 00 : 00 : 30.050
신경망을 말하는 것은
몹시 흥분되는 일입니다.

10
00 : 00 : 30.050 -> 00 : 00 : 35.965
이제 시작하겠습니다. 로지스틱 회귀의 
4개의 porpagation 단계를 검토해 봅시다.

11
00 : 00 : 35.965 -> 00 : 00 : 37.860
당신이 m의 훈련 데이터를 갖고 있다면

12
00 : 00 : 37.860 -> 00 : 00 : 40.605
첫 번째 데이터를 예측하기 위해

13
00 : 00 : 40.605 -> 00 : 00 : 42.105
이 계산이 필요합니다

14
00 : 00 : 42.105 -> 00 : 00 : 45.480
이 익숙한 수식을 사용하여
z를 계산합니다

15
00 : 00 : 45.480 -> 00 : 00 : 47.370
다음 activation 식을 계산합니다

16
00 : 00 : 47.370 -> 00 : 00 : 49.485
그 다음 첫 번째 데이터의
y hat을 계산합니다

17
00 : 00 : 49.485 -> 00 : 00 : 52.705
다음 두 번째 데이터
예측하기 위해

18
00 : 00 : 52.705 -> 00 : 00 : 54.405
이 계산이 필요합니다

19
00 : 00 : 54.405 -> 00 : 00 : 57.085
세 번째 데이터의 예측은

20
00 : 00 : 57.085 -> 00 : 00 : 59.045
이것이 필요할 것이고, 등등 계속될 겁니다.

21
00 : 00 : 59.045 -> 00 : 01 : 01.020
m 개의 데이터가 있으면

22
00 : 01 : 01.020 -> 00 : 01 : 03.855
이것을 m 회 실행해야합니다

23
00 : 01 : 03.855 -> 00 : 01 : 08.250
4개의 propagation 단계를 실행하기 위해서는

24
00 : 01 : 08.250 -> 00 : 01 : 13.435
m 개의 학습 데이터의 예측 값을
계산해야합니다

25
00 : 01 : 13.435 -> 00 : 01 : 14.865
그런데 이걸 for loop없이

26
00 : 01 : 14.865 -> 00 : 01 : 17.925
하는 방법이 있습니다

27
00 : 01 : 17.925 -> 00 : 01 : 20.450
어떻게하는지 살펴 봅시다.

28
00 : 01 : 20.450 -> 00 : 01 : 26.455
먼저 행렬 X를 각각의 training데이터 들을

29
00 : 01 : 26.455 -> 00 : 01 : 30.895
다른 열에 쌓아 나가는 것으로 정의하겠습니다.

30
00 : 01 : 30.895 -> 00 : 01 : 33.810
즉 이것은 행렬입니다.

31
00 : 01 : 33.810 -> 00 : 01 : 38.425
(nx, m)의 행렬입니다

32
00 : 01 : 38.425 -> 00 : 01 : 41.885
제가 이걸 Python numpy에서
shape 형태로 썼습니다만,

33
00 : 01 : 41.885 -> 00 : 01 : 50.350
이것은 X는 nx행과 m열의 차원을 가지는 행렬
이라는 것을 의미 하고 있을 뿐입니다

34
00 : 01 : 50.350 -> 00 : 01 : 54.670
먼저 우리가 할 것은
z (1), z (2), z (3)을

35
00 : 01 : 54.670 -> 00 : 01 : 56.512
어떻게 한 번에

36
00 : 01 : 56.512 -> 00 : 01 : 58.665
계산할지를 생각하는 겁니다.

37
00 : 01 : 58.665 -> 00 : 02 : 01.195
사실 이건 한 줄의 코드가 될겁니다.

38
00 : 02 : 01.195 -> 00 : 02 : 06.930
먼저 1부터 m 까지의 행렬을 만듭니다

39
00 : 02 : 06.930 -> 00 : 02 : 13.100
이것은 행벡터 z (1), z (2) 등

40
00 : 02 : 13.100 -> 00 : 02 : 15.405
z (m)까지를

41
00 : 02 : 15.405 -> 00 : 02 : 18.480
계속 계산 할겁니다

42
00 : 02 : 18.480 -> 00 : 02 : 22.175
사실 이것은

43
00 : 02 : 22.175 -> 00 : 02 : 29.225
w의 transpose 곱하기 행렬X
+ 벡터 b를 한 것입니다

44
00 : 02 : 29.225 -> 00 : 02 : 31.040
이 벡터b 는

45
00 : 02 : 31.040 -> 00 : 02 : 33.315
보다시피 b가 계속 될 것 이고

46
00 : 02 : 33.315 -> 00 : 02 : 34.480
이 b, b, b, b, b는

47
00 : 02 : 34.480 -> 00 : 02 : 38.980
1 X m 벡터 또는

48
00 : 02 : 38.980 -> 00 : 02 : 46.725
1 X m 행렬 즉,
m개의 열을 가진 행벡터입니다

49
00 : 02 : 46.725 -> 00 : 02 : 50.495
여러분 행렬의 연산 상황에 따라 다르지만

50
00 : 02 : 50.495 -> 00 : 02 : 56.300
w transpose 곱하기
x (1), x (2) 부터

51
00 : 02 : 56.300 -> 00 : 02 : 58.760
x (m)까지를 곱하기 합니다.

52
00 : 02 : 58.760 -> 00 : 03 : 05.755
즉, w transpose는
행벡터가 될겁니다.

53
00 : 03 : 05.755 -> 00 : 03 : 10.655
이런  행벡터 입니다

54
00 : 03 : 10.655 -> 00 : 03 : 18.614
이 첫 번째 항목을 살펴보면
w의 전치에 x (1)을 곱하고

55
00 : 03 : 18.614 -> 00 : 03 : 22.970
w의 전치에 x (2)를 곱하고
이것이 이어

56
00 : 03 : 22.970 -> 00 : 03 : 29.840
w의 전치에 x (m)을 곱합니다.
다음 b 항목을 살펴보면

57
00 : 03 : 29.840 -> 00 : 03 : 30.960
계속해서

58
00 : 03 : 30.960 -> 00 : 03 : 33.565
b를 모든 요소에
더하면됩니다

59
00 : 03 : 33.565 -> 00 : 03 : 37.650
이제 또 다른
1 X m의 벡터가 나왔습니다.

60
00 : 03 : 37.650 -> 00 : 03 : 38.955
첫 번째 항목

61
00 : 03 : 38.955 -> 00 : 03 : 40.590
두 번째 항목

62
00 : 03 : 40.590 -> 00 : 03 : 42.810
m 개의 항목 까지갑니다

63
00 : 03 : 42.810 -> 00 : 03 : 45.605
이 정의를 보면

64
00 : 03 : 45.605 -> 00 : 03 : 51.250
이 첫 번째 항목은
z (1)의 정의와 완전히 동일합니다

65
00 : 03 : 51.250 -> 00 : 03 : 57.305
두 번째 항목 그리고 다음도
같은 정의가옵니다

66
00 : 03 : 57.305 -> 00 : 04 : 00.035
X가 제공하는 모든

67
00 : 04 : 00.035 -> 00 : 04 : 02.870
training 데이터를 사용하여

68
00 : 04 : 02.870 -> 00 : 04 : 07.400
계속해서 수평으로 쌓아 가면

69
00 : 04 : 07.400 -> 00 : 04 : 11.069
Z를 이렇게
정의 할 수 있습니다

70
00 : 04 : 11.069 -> 00 : 04 : 16.385
소문자 z를 사용하여
수평으로 쌓는 것이죠

71
00 : 04 : 16.385 -> 00 : 04 : 21.080
소문자 x를 training 데이터마다
수평으로 놓으면

72
00 : 04 : 21.080 -> 00 : 04 : 24.350
대문자 변수 X를 얻을 수 있습니다

73
00 : 04 : 24.350 -> 00 : 04 : 27.420
이와 같이
소문자 z 변수를

74
00 : 04 : 27.420 -> 00 : 04 : 28.805
수평으로 쌓아 가면

75
00 : 04 : 28.805 -> 00 : 04 : 34.050
우리가 알고 있는 대문자 변수 Z가됩니다

76
00 : 04 : 34.050 -> 00 : 04 : 37.400
사실이 부분을 구현하려면

77
00 : 04 : 37.400 -> 00 : 04 : 45.773
numpy의 명령은
Z = np.dot (wT, X) + b입니다

78
00 : 04 : 45.773 -> 00 : 04 : 51.095
이 명령은 w의 전치 곱하기 X에서
이에 b를 더해준다는 뜻입니다.

79
00 : 04 : 51.095 -> 00 : 04 : 53.645
Python은 신경써야할 부분이 있는데

80
00 : 04 : 53.645 -> 00 : 04 : 59.405
b는 실수(Real number)로
1 X 1의 행렬입니다

81
00 : 04 : 59.405 -> 00 : 05 : 01.330
보통 실수이지만

82
00 : 05 : 01.330 -> 00 : 05 : 06.230
이 벡터에 실수를 더하면

83
00 : 05 : 06.230 -> 00 : 05 : 13.235
Python은 자동으로
실수 b를 1 x m 열 벡터로 확장합니다

84
00 : 05 : 13.235 -> 00 : 05 : 16.490
이 연산이 조금 미스테리하게 보일수 있지만,

85
00 : 05 : 16.490 -> 00 : 05 : 20.120
이 "brodcasting" 이라는 이름의 연산이 말이죠.

86
00 : 05 : 20.120 -> 00 : 05 : 22.210
지금 이것은 걱정하지 마십시오

87
00 : 05 : 22.210 -> 00 : 05 : 25.760
다음 동영상에서
더 설명합니다

88
00 : 05 : 25.760 -> 00 : 05 : 29.180
여기서 기억 주었으면 하는 것은
이 단 한 줄의 코드

89
00 : 05 : 29.180 -> 00 : 05 : 33.290
대문자 Z를 계산할 수 있는 이 코드입니다.

90
00 : 05 : 33.290 -> 00 : 05 : 37.698
대문자 Z는 1 x m 행렬로 되어 있습니다
소문자 z를 모두 포함하고 있구요,

91
00 : 05 : 37.698 -> 00 : 05 : 41.200
z (1)에서 z (m)까지입니다

92
00 : 05 : 41.200 -> 00 : 05 : 46.255
이것이 대문자 Z입니다.
그렇다면 A들의 값은 어떻습니까?

93
00 : 05 : 46.255 -> 00 : 05 : 48.260
다음 작업은

94
00 : 05 : 48.260 -> 00 : 05 : 52.685
a (1)에서 a (2)
그리고 a (m)까지

95
00 : 05 : 52.685 -> 00 : 05 : 57.220
한번에 계산을 수행하는 방법을

96
00 : 05 : 57.220 -> 00 : 05 : 58.700
찾습니다

97
00 : 05 : 58.700 -> 00 : 06 : 03.350
소문자 x를 수평으로 첨가하여

98
00 : 06 : 03.350 -> 00 : 06 : 08.870
대문자 X가 된 것처럼

99
00 : 06 : 08.870 -> 00 : 06 : 10.810
소문자 a를 거듭해 가면

100
00 : 06 : 10.810 -> 00 : 06 : 12.470
새로운 변수 대문자 A를

101
00 : 06 : 12.470 -> 00 : 06 : 15.200
정의 할 수 있습니다

102
00 : 06 : 15.200 -> 00 : 06 : 18.075
이 후 프로그래밍 과제 에서는

103
00 : 06 : 18.075 -> 00 : 06 : 22.790
벡터화된 sigmoid 함수를
구현하는 방법이 나옵니다

104
00 : 06 : 22.790 -> 00 : 06 : 24.480
sigmoid 함수는

105
00 : 06 : 24.480 -> 00 : 06 : 32.380
이 대문자 Z를 입력하고
매우 효율적으로 대문자 A를 출력하는 것입니다

106
00 : 06 : 32.380 -> 00 : 06 : 36.620
프로그래밍 과제에서
자세히 소개하고 있습니다

107
00 : 06 : 36.620 -> 00 : 06 : 38.110
정리하면

108
00 : 06 : 38.110 -> 00 : 06 : 42.655
이 슬라이드에서 본 것은
m개의 training 데이터에서

109
00 : 06 : 42.655 -> 00 : 06 : 47.515
소문자 z와 소문자 a를
하나씩 계산하는 m의 루프 대신에

110
00 : 06 : 47.515 -> 00 : 06 : 52.090
이 한 줄의 코드를 구현함으로써

111
00 : 06 : 52.090 -> 00 : 06 : 54.290
모든 z를
한 번에 계산할 수 있습니다

112
00 : 06 : 54.290 -> 00 : 06 : 57.100
또한 이 한 줄의 코드는

113
00 : 06 : 57.100 -> 00 : 06 : 59.260
소문자 시그마를

114
00 : 06 : 59.260 -> 00 : 07 : 04.115
계산하는 적절한 구현 방법으로서,
모든 소문자 a를 한 번에 계산합니다

115
00 : 07 : 04.115 -> 00 : 07 : 05.965
이것이 벡터화를

116
00 : 07 : 05.965 -> 00 : 07 : 07.948
모든 훈련 데이터 m에 대해서

117
00 : 07 : 07.948 -> 00 : 07 : 11.560
4개의 propagation에서 실행하는 방법입니다

118
00 : 07 : 11.560 -> 00 : 07 : 13.985
정리하면
여기에서는

119
00 : 07 : 13.985 -> 00 : 07 : 18.100
벡터화하여
activation 함수의 소문자 a를

120
00 : 07 : 18.100 -> 00 : 07 : 21.700
매우 효율적으로
계산하는 방법을보고 왔습니다

121
00 : 07 : 21.700 -> 00 : 07 : 24.860
다음은 기울기를 계산하기 위한
back propagation에도

122
00 : 07 : 24.860 -> 00 : 07 : 27.910
벡터화를 이용하여 매우 효율적으로 
계산하는 방법을

123
00 : 07 : 27.910 -> 00 : 07 : 29.650
사용할 수 있습니다

124
00 : 07 : 29.650 -> 00 : 07 : 32.000
다음 비디오에서 확인합시다.