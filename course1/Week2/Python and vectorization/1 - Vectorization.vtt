WEBVTT

1
00 : 00 : 00.000 -> 00 : 00 : 03.195
돌아 온걸 환영합니다!
벡터화는

2
00 : 00 : 03.195 -> 00 : 00 : 07.315
for loop를 코드에
쓰지 않도록하는 기술입니다

3
00 : 00 : 07.315 -> 00 : 00 : 11.835
딥러닝 시대에는

4
00 : 00 : 11.835 -> 00 : 00 : 15.210
비교적 큰 데이터 세트를
학습에 사용하는 경우가 많습니다.

5
00 : 00 : 15.210 -> 00 : 00 : 18.475
이런 상황에서 바로
딥러닝 알고리즘이 제 역할을 하기 때문입니다.

6
00 : 00 : 18.475 -> 00 : 00 : 22.790
코드의 실행 속도는
빠른 것이 중요합니다

7
00 : 00 : 22.790 -> 00 : 00 : 24.525
그렇지 않으면
데이터가 커진 경우에는

8
00 : 00 : 24.525 -> 00 : 00 : 27.000
학습을 진행할 시에
코드의 실행에 장시간이 소요될 것이고,

9
00 : 00 : 27.000 -> 00 : 00 : 30.255
결과가 나올 때까지
아주 오래 기다릴 것입니다

10
00 : 00 : 30.255 -> 00 : 00 : 32.035
따라서 딥러닝의 시대에는

11
00 : 00 : 32.035 -> 00 : 00 : 37.490
벡터화하는 기술이
매우 중요한 요소가 되었습니다.

12
00 : 00 : 37.490 -> 00 : 00 : 40.010
우선 예를 한번 봅시다.

13
00 : 00 : 40.010 -> 00 : 00 : 42.225
벡터화는 무엇일까요?

14
00 : 00 : 42.225 -> 00 : 00 : 48.780
로지스틱 회귀모델 에서 당신은
Z = W transpose 곱하기 X + b를 계산 해야합니다

15
00 : 00 : 48.780 -> 00 : 00 : 55.405
W는 열 벡터
X도 열 벡터입니다

16
00 : 00 : 55.405 -> 00 : 00 : 58.000
많은 feature가 있는 경우
매우 큰 벡터가 되겠지요

17
00 : 00 : 58.000 -> 00 : 01 : 07.080
W와 X 모두 R의 nX 차원 벡터입니다

18
00 : 01 : 07.080 -> 00 : 01 : 10.170
W의 transpose 곱하기 X의 계산을

19
00 : 01 : 10.170 -> 00 : 01 : 15.660
벡터화하지 않고 구현하는 경우에는

20
00 : 01 : 15.660 -> 00 : 01 : 18.725
이런 식으로하는 것입니다
먼저 Z = 0으로 쓰고

21
00 : 01 : 18.725 -> 00 : 01 : 24.860
for i in range (nX)로 작성

22
00 : 01 : 24.860 -> 00 : 01 : 27.330
i는 1부터 nX입니다

23
00 : 01 : 27.330 -> 00 : 01 : 34.040
Z += W [i] * X [i]라고 쓰고

24
00 : 01 : 34.040 -> 00 : 01 : 37.100
Z += b를 마지막으로 쓰는 것이

25
00 : 01 : 37.100 -> 00 : 01 : 39.855
이것이 벡터화하지 않는 경우
구현하는 방법입니다.

26
00 : 01 : 39.855 -> 00 : 01 : 43.090
당신도 느끼셨겠지만 이건 굉장히 느릴겁니다.

27
00 : 01 : 43.090 -> 00 : 01 : 48.560
대조적으로 벡터화한 실행 방법은
W의 transpose 곱하기 X를 직접 계산합니다

28
00 : 01 : 48.560 -> 00 : 01 : 52.085
Python 또는 numpy는

29
00 : 01 : 52.085 -> 00 : 02 : 01.428
Z = np.dot (W, X) 명령을 사용합니다

30
00 : 02 : 01.428 -> 00 : 02 : 06.270
이제 W의 tranpose 곱하기 X 를
계산할 수 있습니다

31
00 : 02 : 06.270 -> 00 : 02 : 09.075
여기에 b를 더하기만 하면 되는 겁니다.

32
00 : 02 : 09.075 -> 00 : 02 : 12.400
당신은 방법이 더 빠른 것을 알 수 있습니다

33
00 : 02 : 12.400 -> 00 : 02 : 17.075
약간의 데모로 실제로 설명해 보겠습니다.

34
00 : 02 : 17.075 -> 00 : 02 : 21.960
Jupyter Notebook내에서
Python의 코드를 작성합니다

35
00 : 02 : 21.960 -> 00 : 02 : 28.041
우선 numpy 라이브러리를
np로 가져옵니다

36
00 : 02 : 28.041 -> 00 : 02 : 30.000
이렇게요, 그리고 예를 들면

37
00 : 02 : 30.000 -> 00 : 02 : 36.570
a를 이렇게
array로 만듭니다

38
00 : 02 : 36.570 -> 00 : 02 : 39.560
print (a)
해 보자

39
00 : 02 : 39.560 -> 00 : 02 : 41.160
이런 식으로 코드를 작성하고

40
00 : 02 : 41.160 -> 00 : 02 : 43.170
shift + enter를 누르면

41
00 : 02 : 43.170 -> 00 : 02 : 44.847
코드가 실행됩니다.

42
00 : 02 : 44.847 -> 00 : 02 : 47.970
array a를 만들고
결과를 출력합니다

43
00 : 02 : 47.970 -> 00 : 02 : 50.580
벡터화한 데모를 봅시다.

44
00 : 02 : 50.580 -> 00 : 02 : 51.990
time 라이브러리를
가져옵니다

45
00 : 02 : 51.990 -> 00 : 02 : 53.580
이것을 사용해서

46
00 : 02 : 53.580 -> 00 : 02 : 56.565
다른 연산의 진행 시간
측정합니다

47
00 : 02 : 56.565 -> 00 : 02 : 59.139
array a를 만듭니다

48
00 : 02 : 59.139 -> 00 : 03 : 02.905
random.rand에서

49
00 : 03 : 02.905 -> 00 : 03 : 10.065
랜덤한 값들의
array를 백만개 만듭니다

50
00 : 03 : 10.065 -> 00 : 03 : 13.300
b = np.random.rand에서

51
00 : 03 : 13.300 -> 00 : 03 : 16.120
또 array를 백만개 만듭니다

52
00 : 03 : 16.120 -> 00 : 03 : 20.810
tic = time.time ()

53
00 : 03 : 20.810 -> 00 : 03 : 26.395
c = np.dot (a, b)라고 씁니다

54
00 : 03 : 26.395 -> 00 : 03 : 28.649
toc = time.time ()라고 쓰고

55
00 : 03 : 28.649 -> 00 : 03 : 31.950
print를 사용하여

56
00 : 03 : 31.950 -> 00 : 03 : 34.857
벡터화 버전을 나타내도록

57
00 : 03 : 34.857 -> 00 : 03 : 37.685
vectorize version :라고 씁니다

58
00 : 03 : 37.685 -> 00 : 03 : 41.985
이제 이걸 프린트해 봅시다.

59
00 : 03 : 41.985 -> 00 : 03 : 45.060
마지막으로, 시간 표현은

60
00 : 03 : 45.060 -> 00 : 03 : 48.330
(toc-tic) 곱하기 1,000을 쓰고

61
00 : 03 : 48.330 -> 00 : 03 : 52.075
밀리 초 단위로
표현하게합니다

62
00 : 03 : 52.075 -> 00 : 03 : 54.075
ms 밀리 초입니다

63
00 : 03 : 54.075 -> 00 : 03 : 56.435
shift + enter를 누릅니다

64
00 : 03 : 56.435 -> 00 : 04 : 01.890
코드의 실행 시간은
약 3 밀리 초 또는 1.5 밀리 초였습니다

65
00 : 04 : 01.890 -> 00 : 04 : 06.170
1.5 밀리 초 또는
3.5 밀리 초 정도 걸리기도 합니다

66
00 : 04 : 06.170 -> 00 : 04 : 08.370
조금 실행 시간에 차이가 있지만

67
00 : 04 : 08.370 -> 00 : 04 : 12.085
평균 1.5 밀리 초 또는 2 밀리 초 정도가

68
00 : 04 : 12.085 -> 00 : 04 : 15.665
실행 시간으로 걸리네요

69
00 : 04 : 15.665 -> 00 : 04 : 16.967
그래요,

70
00 : 04 : 16.967 -> 00 : 04 : 19.005
그냥 여기에 코드를 추가해 봅시다.

71
00 : 04 : 19.005 -> 00 : 04 : 22.270
벡터화하지 않는 코드를
추가해 보겠습니다.

72
00 : 04 : 22.270 -> 00 : 04 : 24.151
c = 0으로 쓰고

73
00 : 04 : 24.151 -> 00 : 04 : 27.750
tic = time.time ()라고 쓴다

74
00 : 04 : 27.750 -> 00 : 04 : 29.335
for loop를 구현합니다

75
00 : 04 : 29.335 -> 00 : 04 : 35.348
for i in range (1000000)라고 쓴다

76
00 : 04 : 35.348 -> 00 : 04 : 38.676
0개수는 제대로 쓴것 같군요,

77
00 : 04 : 38.676 -> 00 : 04 : 43.936
C + = a [i] * b [i]라고 쓰고

78
00 : 04 : 43.936 -> 00 : 04 : 50.775
toc = time.time ()라고 씁니다.

79
00 : 04 : 50.775 -> 00 : 04 : 57.725
마지막으로 for loop를
print합니다

80
00 : 04 : 57.725 -> 00 : 05 : 15.225
경과 시간은 1,000 * (toc -tic) + ms에서

81
00 : 05 : 15.225 -> 00 : 05 : 17.505
밀리 세컨드임을
나타냅니다

82
00 : 05 : 17.505 -> 00 : 05 : 19.735
하나 더 추가하겠습니다.

83
00 : 05 : 19.735 -> 00 : 05 : 22.802
계산 된 c의 값을 프린트해서

84
00 : 05 : 22.802 -> 00 : 05 : 27.960
두 가지 방법에서 동일한 값 인지
확인할 수 있도록 합니다

85
00 : 05 : 27.960 -> 00 : 05 : 35.770
shift + enter를 눌러 실행합니다

86
00 : 05 : 35.770 -> 00 : 05 : 38.305
벡터화 버전에서도

87
00 : 05 : 38.305 -> 00 : 05 : 41.125
비 벡터화 버전에서도
같은 값이 계산되었습니다

88
00 : 05 : 41.125 -> 00 : 05 : 45.355
250286.99 ... 이어지는 값입니다

89
00 : 05 : 45.355 -> 00 : 05 : 48.670
벡터화 버전에서는
1.5 밀리 세컨드로

90
00 : 05 : 48.670 -> 00 : 05 : 57.555
for loop를 사용한 비 벡터 버전에서는
약 400에서 500 밀리 초를 초과하는 시간입니다

91
00 : 05 : 57.555 -> 00 : 06 : 01.285
비 벡터 버전은 약 300 배 정도

92
00 : 06 : 01.285 -> 00 : 06 : 05.660
벡터 버전보다
오랜 시간이 걸렸습니다

93
00 : 06 : 05.660 -> 00 : 06 : 11.230
이 예에서 보듯이 벡터화를 할 경우

94
00 : 06 : 11.230 -> 00 : 06 : 15.120
코드는 300 배 이상 빠르게
작동합니다

95
00 : 06 : 15.120 -> 00 : 06 : 16.540
다시 한번 실행 해 봅시다

96
00 : 06 : 16.540 -> 00 : 06 : 18.930
실행했습니다

97
00 : 06 : 18.930 -> 00 : 06 : 22.235
벡터화 버전은 1.5 밀리 세컨드

98
00 : 06 : 22.235 -> 00 : 06 : 25.960
for loop 버전은 481 밀리 초 걸렸습니다

99
00 : 06 : 25.960 -> 00 : 06 : 29.535
여기서도 for loop는
300 분의 1의 속도였습니다

100
00 : 06 : 29.535 -> 00 : 06 : 30.980
300 배 느린 경우

101
00 : 06 : 30.980 -> 00 : 06 : 33.880
연산을 1 분에 완료하느냐

102
00 : 06 : 33.880 -> 00 : 06 : 37.615
5 시간이 걸리느냐의 차이 입니다.

103
00 : 06 : 37.615 -> 00 : 06 : 41.410
딥러닝 알고리즘을
구현하는 경우에는

104
00 : 06 : 41.410 -> 00 : 06 : 43.300
결과가 빠르게
되돌아옵니다

105
00 : 06 : 43.300 -> 00 : 06 : 46.590
하지만 벡터화하면 결과가
더 빨리 계산됩니다.

106
00 : 06 : 46.590 -> 00 : 06 : 49.300
규모가 큰 딥러닝의 구현은

107
00 : 06 : 49.300 -> 00 : 06 : 54.260
GPU (그래픽 처리 장치)에서 실행 된다는 것을
들어본 적이 있을지도 모릅니다.

108
00 : 06 : 54.260 -> 00 : 06 : 59.515
여기에서 지금 실행 한 Jupyter Notebook에서의 
데모버전은, CPU에서 실행했습니다

109
00 : 06 : 59.515 -> 00 : 07 : 04.530
사실 GPU도 CPU도 둘 다
병렬 처리 명령이 있습니다

110
00 : 07 : 04.530 -> 00 : 07 : 07.530
SIMD 명령이라고합니다

111
00 : 07 : 07.530 -> 00 : 07 : 11.190
Single Instruction Multiple Data의
약어입니다

112
00 : 07 : 11.190 -> 00 : 07 : 13.045
이것이 의미하는 것은

113
00 : 07 : 13.045 -> 00 : 07 : 16.835
np.dot 함수 나
다른 함수와 같이

114
00 : 07 : 16.835 -> 00 : 07 : 23.495
for loop를 사용하지 않아도 되는 
내장된 함수를 사용하면

115
00 : 07 : 23.495 -> 00 : 07 : 28.150
Python의 numpy가

116
00 : 07 : 28.150 -> 00 : 07 : 33.640
계산 처리를 신속하게 할 수있는
병렬 처리를 상당히 효율적으로 사용 할 수 있습니다

117
00 : 07 : 33.640 -> 00 : 07 : 38.610
이것은 CPU의 연산도
GPU의 연산도 마찬가지입니다

118
00 : 07 : 38.610 -> 00 : 07 : 41.070
단지 GPU는 SIMD 계산을

119
00 : 07 : 41.070 -> 00 : 07 : 44.980
놀라울 정도로 효율적으로 할 수있을뿐
CPU의 계산도 사실 그리 나쁘지 않습니다

120
00 : 07 : 44.980 -> 00 : 07 : 47.510
GPU 정도로는
좋지 않을 뿐입니다

121
00 : 07 : 47.510 -> 00 : 07 : 51.660
여러분은 벡터화하면
코드의 속도가 상당히 올라가는 것을 보고 왔습니다

122
00 : 07 : 51.660 -> 00 : 07 : 54.685
기억해야 할 교훈은

123
00 : 07 : 54.685 -> 00 : 07 : 57.425
for loop를
사용하지 않도록하는 것입니다

124
00 : 07 : 57.425 -> 00 : 07 : 59.980
다음 비디오로 이동해서
벡터화의 다른 예를보고

125
00 : 07 : 59.980 -> 00 : 08 : 04.000
로지스틱 회귀를
벡터화 해봅시다