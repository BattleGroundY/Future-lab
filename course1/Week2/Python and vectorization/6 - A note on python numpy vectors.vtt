WEBVTT

1
00 : 00 : 00.450 -> 00 : 00 : 04.786
Python에서
broadcasting을 사용할 수 있다는 점, 

2
00 : 00 : 04.786 -> 00 : 00 : 09.944
더 일반적으로 말하면
Python 또는 Numpy에 높은 수준의 유연성이 있다는 점은

3
00 : 00 : 09.944 -> 00 : 00 : 14.748
프로그램 언어로서
강점이기도 약점이기도합니다

4
00 : 00 : 14.748 -> 00 : 00 : 18.393
강점면으로는
언어가 높은 표현과 유연성을 가지고있는 것으로

5
00 : 00 : 18.393 -> 00 : 00 : 22.547
단 한 줄의 코드도
많은 것을 할 수 있도록

6
00 : 00 : 22.547 -> 00 : 00 : 24.165
하는 점 입니다.

7
00 : 00 : 24.165 -> 00 : 00 : 28.530
물론 약점 이기도합니다.

8
00 : 00 : 28.530 -> 00 : 00 : 32.610
당신이 broadcasting을 구현한다면 

9
00 : 00 : 32.610 -> 00 : 00 : 36.530
미세하거나 이상하게 생긴 버그를

10
00 : 00 : 36.530 -> 00 : 00 : 39.800
찾아내는 것이 어려워질 수도 있습니다.

11
00 : 00 : 39.800 -> 00 : 00 : 44.500
예를 들어 열 벡터에
행 벡터를 더할때

12
00 : 00 : 44.500 -> 00 : 00 : 48.700
당신은 행렬 차원의 불일치 또는 형식 오류 등을
예상 하겠지만

13
00 : 00 : 48.700 -> 00 : 00 : 52.620
실제로는 행 벡터와
열 벡터의 합이

14
00 : 00 : 52.620 -> 00 : 00 : 54.030
정상적으로 되돌아옵니다

15
00 : 00 : 54.030 -> 00 : 00 : 58.370
이와 같은 Python의 이상한 행동은
내부 logic이 있기 때문입니다.

16
00 : 00 : 58.370 -> 00 : 01 : 03.370
그러나 Python에 익숙하지 않은 경우
이상하고, 매우 찾기 힘든 버그가 발생되는 

17
00 : 01 : 03.370 -> 00 : 01 : 05.680
경우도 많았습니다.

18
00 : 01 : 05.680 -> 00 : 01 : 09.380
그래서 이 비디오에서는
코드에 있는 이상한 버그를 배제하고

19
00 : 01 : 09.380 -> 00 : 01 : 12.800
간단하게 코드를 작성하는데
매우 도움이 되는 요령을

20
00 : 01 : 12.800 -> 00 : 01 : 17.320
공유하고 싶습니다

21
00 : 01 : 17.320 -> 00 : 01 : 19.280
이러한 요령을 사용하여

22
00 : 01 : 19.280 -> 00 : 01 : 24.193
버그없는 Python 또는 numpy 코드를
쉽게 쓸 수 있게 되었으면 합니다

23
00 : 01 : 25.430 -> 00 : 01 : 30.200
직관적으로 이해하기 어려운
Python 또는 numpy의 결과를

24
00 : 01 : 30.200 -> 00 : 01 : 34.990
보여드리기 위해서
데모를 하나 만들어 보겠습니다.

25
00 : 01 : 34.990 -> 00 : 01 : 40.817
a = np.random.randn (5)라고 쓰고

26
00 : 01 : 40.817 -> 00 : 01 : 45.699
이 의미는 가우스 분포의 랜덤 변수를
5 개 제작해서

27
00 : 01 : 45.699 -> 00 : 01 : 49.640
이를 array a에 기록한다는 의미입니다.

28
00 : 01 : 49.640 -> 00 : 01 : 55.420
print (a)를 실행해 보면 이렇게 되죠.
또한 a의 shape인 a.shape은

29
00 : 01 : 55.420 -> 00 : 02 : 02.740
(5,) 라는 구조로 되어 있네요

30
00 : 02 : 02.740 -> 00 : 02 : 06.320
이것은 파이썬에서 rank 1 array라고 부릅니다.

31
00 : 02 : 06.320 -> 00 : 02 : 09.750
그리고 이건 행 벡터도 아니고
열 벡터도 아닙니다.

32
00 : 02 : 09.750 -> 00 : 02 : 12.570
이것은 다소 직관적이지 못한 결과를 냅니다.

33
00 : 02 : 12.570 -> 00 : 02 : 17.180
예를 들어 a의 transpose를 print하면
a와 완전히 같은 결과가 됩니다

34
00 : 02 : 17.180 -> 00 : 02 : 20.220
a와 aT가 같은 결과가
되어 버립니다

35
00 : 02 : 20.220 -> 00 : 02 : 25.800
그리고 a와 aT의 외적(Outer product)을
print하면

36
00 : 02 : 25.800 -> 00 : 02 : 30.190
a × aT가 출력값으로 행렬을 되돌려 줄 것을
예상할지도 모르지만,

37
00 : 02 : 30.190 -> 00 : 02 : 34.170
이렇게하면
그 대신에 하나의 숫자가 되돌아옵니다

38
00 : 02 : 34.170 -> 00 : 02 : 39.612
따라서 신경망을
코딩 할 때

39
00 : 02 : 39.612 -> 00 : 02 : 46.115
(5,)와 (n,) 나 rank 1 array과 같은 모양의 구조를
사용하지 않는 것이 좋습니다

40
00 : 02 : 46.115 -> 00 : 02 : 52.134
그 대신에
a를 (5,1)으로 지정하면

41
00 : 02 : 52.134 -> 00 : 02 : 58.764
a가 (5,1)의 열 벡터가 될겁니다.

42
00 : 02 : 58.764 -> 00 : 03 : 02.399
아까 연산 결과로는 a 와 aT는
동일한 결과를 얻었지만 

43
00 : 03 : 02.399 -> 00 : 03 : 06.590
이번에 aT을 print하면
행벡터화 되어 있습니다

44
00 : 03 : 06.590 -> 00 : 03 : 08.437
미묘한 차이에 주목하십시오

45
00 : 03 : 08.437 -> 00 : 03 : 12.213
print 한 aT의 데이터 구조에는
[가 2 개 있습니다

46
00 : 03 : 12.213 -> 00 : 03 : 14.460
이전의 연산에서는
[하나였습니다

47
00 : 03 : 14.460 -> 00 : 03 : 19.393
이것이
이 (1,5)의 행렬과

48
00 : 03 : 19.393 -> 00 : 03 : 23.481
이 rank 1 array의 차이였습니다

49
00 : 03 : 23.481 -> 00 : 03 : 28.129
a와 aT의 곱을 print하면

50
00 : 03 : 28.129 -> 00 : 03 : 32.444
벡터의 외적을 계산 해주고,

51
00 : 03 : 32.444 -> 00 : 03 : 35.795
벡터의 외적 행렬을 반환합니다

52
00 : 03 : 35.795 -> 00 : 03 : 40.305
우리는 방금 매우 자세한 부분까지
보고 왔습니다

53
00 : 03 : 40.305 -> 00 : 03 : 43.185
처음 실행 한 첫 번째 명령은
이것이었습니다

54
00 : 03 : 43.185 -> 00 : 03 : 47.839
이 명령은
이상한 구조를 만들었습니다

55
00 : 03 : 47.839 -> 00 : 03 : 52.930
a.shape에서 보면
(5,) 이었고

56
00 : 03 : 52.930 -> 00 : 03 : 57.270
이를 rank 1 array 라고합니다

57
00 : 03 : 57.270 -> 00 : 03 : 58.960
이것은 매우 이상한 데이터 구조입니다.

58
00 : 03 : 58.960 -> 00 : 04 : 04.000
행 벡터와 열 벡터 중 어느 것으로도 작동하지 않고

59
00 : 04 : 04.000 -> 00 : 04 : 06.750
직관적이지 않은 결과를 냅니다.

60
00 : 04 : 06.750 -> 00 : 04 : 10.770
당신이 프로그램 연습을 하면서
로지스틱 회귀나 신경망을 구동 시킬때

61
00 : 04 : 10.770 -> 00 : 04 : 14.050
제가 추천드리는 것은

62
00 : 04 : 14.050 -> 00 : 04 : 19.020
이 rank 1 array를 사용하지 않는 것이
좋다는 것입니다.

63
00 : 04 : 19.020 -> 00 : 04 : 21.098
대신에 배열을 만들 때마다

64
00 : 04 : 21.098 -> 00 : 04 : 24.500
(5,1) 처럼 열 벡터나

65
00 : 04 : 24.500 -> 00 : 04 : 32.360
행 벡터로 지정하도록 합시다.

66
00 : 04 : 32.360 -> 00 : 04 : 36.670
이렇게 되면 벡터값들의 구동을
더욱 이해하기 쉬울겁니다.

67
00 : 04 : 36.670 -> 00 : 04 : 43.115
이 경우에는 a.shape은
(5,1)이 될 것이고,

68
00 : 04 : 43.115 -> 00 : 04 : 48.510
이것은 열 벡터처럼 보이고,
실제로 열 벡터입니다.

69
00 : 04 : 48.510 -> 00 : 04 : 53.233
또는 (5,1)의 행렬처럼 생각할 수도 있습니다

70
00 : 04 : 53.233 -> 00 : 04 : 56.880
그리고이 경우에는
a.shape는 (1,5)이 될겁니다.

71
00 : 04 : 56.880 -> 00 : 05 : 01.000
이것은 행 벡터와 동일하게 동작합니다

72
00 : 05 : 02.150 -> 00 : 05 : 06.258
그래서 벡터가 필요한 때
이것들 중 하나를 사용하고

73
00 : 05 : 06.258 -> 00 : 05 : 07.538
rank 1 array는 사용하지 맙시다.

74
00 : 05 : 07.538 -> 00 : 05 : 12.061
또 하나 제가 코드에서 자주 실시하는 것은
벡터의 차원 수가

75
00 : 05 : 12.061 -> 00 : 05 : 17.029
완전히 파악되지 않을 때는
assert 구문을 넣어 둡니다

76
00 : 05 : 17.029 -> 00 : 05 : 21.720
이렇게 이 경우에는

77
00 : 05 : 21.720 -> 00 : 05 : 23.730
(5,1)의 열벡터임을 보장 받습니다.

78
00 : 05 : 23.730 -> 00 : 05 : 26.900
이러한 assert는
코드 속도에 영향을 거의 주지 않고,

79
00 : 05 : 26.900 -> 00 : 05 : 30.250
코드에 대한 파악에 큰 도움을 주기 때문에

80
00 : 05 : 30.250 -> 00 : 05 : 34.160
이 구문을 넣고 싶어진다면

81
00 : 05 : 34.160 -> 00 : 05 : 35.320
assert 구문을 주저없이 넣도록 합시다

82
00 : 05 : 35.320 -> 00 : 05 : 39.510
마지막으로 어쩔수 없는 원인에 의해
rank 1 array가 생긴 경우

83
00 : 05 : 39.510 -> 00 : 05 : 43.960
a.reshape (5,1)등을 이용해서
모양을 바꿀 수 있습니다

84
00 : 05 : 43.960 -> 00 : 05 : 48.900
(5,1) 배열이거나 (1,5) 배열로 변경해서

85
00 : 05 : 48.900 -> 00 : 05 : 53.750
열 벡터 또는 행 벡터와
유사한 행동을 하게 합니다

86
00 : 05 : 53.750 -> 00 : 05 : 57.626
학생들이 버그를 찾기 어려워 하는걸
종종 본적이 있는데,

87
00 : 05 : 57.626 -> 00 : 06 : 01.119
이는 rank 1 array의 직관적이지 않은 결과 때문입니다

88
00 : 06 : 01.119 -> 00 : 06 : 06.246
rank 1 array을 제거함으로써
코드를 단순화 할 수있고,

89
00 : 06 : 06.246 -> 00 : 06 : 09.463
이를 제거 함으로써 코드로 
표현할 수있는 것들에

90
00 : 06 : 09.463 -> 00 : 06 : 10.335
제약이 생긴다고 느낀 적은 없습니다

91
00 : 06 : 10.335 -> 00 : 06 : 12.469
그래서 저는 rank 1 array는
절대로 사용하지 않습니다

92
00 : 06 : 12.469 -> 00 : 06 : 17.090
기억 하셨으면 하는건, 코드를 단순화하고 
유지하기 위하여 rank 1 array는 사용하지마시고

93
00 : 06 : 17.090 -> 00 : 06 : 19.437
열 벡터인 (n, 1)의 행렬을 사용하거나

94
00 : 06 : 19.437 -> 00 : 06 : 24.510
행 벡터인 (1, n) 행렬을
항상 사용하시기 바랍니다.

95
00 : 06 : 24.510 -> 00 : 06 : 26.599
그리고 다음으로는, 많은 assert 문을
넣는 것을 주저하지 맙시다

96
00 : 06 : 26.599 -> 00 : 06 : 29.590
이를 이용해서 행렬과 배열의 차원 수를
다시 한번 확인 하도록 합시다

97
00 : 06 : 29.590 -> 00 : 06 : 34.480
또한 reshape도
두려워하지 말고 사용해서

98
00 : 06 : 34.480 -> 00 : 06 : 38.780
행렬과 벡터가 필요한 차원 수로
구성되어 있도록 해줍시다.

99
00 : 06 : 38.780 -> 00 : 06 : 39.420
이제 이러한 요령을 사용하는 것으로

100
00 : 06 : 39.420 -> 00 : 06 : 44.770
Python의 코드에서 버그의 원인을 제거하고

101
00 : 06 : 44.770 -> 00 : 06 : 48.840
당신이 프로그램 연습을
더 쉽게 완료 할 수 있으면 좋겠군요.